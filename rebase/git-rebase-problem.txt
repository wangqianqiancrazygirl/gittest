1. git pull --rebase

2. git fetch <remote-name>/<branch-name>
  git rebase <remote-name>/<branch-name>

用于变基问题
(别人提交了代码 你合并了 他把提交的代码强制变基重新提交 此时你直接合并会有问题)

变基的风险
呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：
不要对在你的仓库外有副本的分支执行变基。
如果你遵循这条金科玉律，就不会出差错。	否则，人民群众会仇恨你，你的朋友和家人也会 嘲笑你，唾弃你。
变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提 交。	如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工 作，此时，如果你用git rebase命令重新整理了提交并再次推送，你的同伴因此将不得不 再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提 交，事情就会变得一团糟。
让我们来看一个在公开的仓库上执行变基操作所带来的问题。	
假设你从一个中央服务器克隆 然后在它的基础上进行了一些开发。

Figure	10.	克隆一个仓库，然后在它的基础上进行了一些开发 然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。	你抓取了这些在远程分 支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：

Figure	11.	抓取别人的提交，合并到自己的开发分支 接下来，这个人又决定把合并操作回滚，改用变基；继而又用		git	push	--force		命令覆盖了 服务器上的提交历史。	之后你从服务器抓取更新，会发现多出来一些新的提交。

Figure	12.	有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 结果就是你们两人的处境都十分尴尬。	如果你执行		git	pull		命令，你将合并来自两条提交 历史的内容，生成一个新的合并提交，最终仓库会如图所示：

Figure	13.	你将相同的内容又合并了一次，生成了一个新的提交 此时如果你执行		git	log		命令，你会发现有两个提交的作者、日期、日志居然是一样的，这 会令人感到混乱。	此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基 抛弃的提交又找了回来，这会令人感到更加混乱。	很明显对方并不想在提交历史中看到		C4	和		C6	，因为之前就是他们把这两个提交通过变基丢弃的。

用变基解决变基

如果你	真的	遭遇了类似的处境，Git	还有一些高级魔法可以帮到你。	如果团队中的某人强制 推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了 哪些修改。
实际上，Git	除了对整个提交计算	SHA-1	校验和以外，也对本次提交所引入的修改计算了校 验和――	即	``patch-id''。
如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下	Git	都能成功 分辨出哪些是你的修改，并把它们应用到新分支上。
举个例子，如果遇到前面提到的	有人推送了经过变基的提交，并丢弃了你的本地开发所基于 的一些提交	那种情境，如果我们不是执行合并，而是执行		git	rebase	teamone/master	,	Git	将 会：
检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）
检查其中哪些提交不是合并操作的结果（C2，C3，C4）
检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有	C2	和	C3，因为	C4	其实 就是	C4'）
把查到的这些提交应用在		teamone/master		上面
从而我们将得到与	你将相同的内容又合并了一次，生成了一个新的提交	中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基	所示。

	